from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import hashlib
print("**복호화**")

# 복호화에 사용할 사용자 암호를 입력받는다. 당연히 암호화시의 사용자 암호와 동일해야 한다.
original_password = input("password: ").encode('utf8')

# 사용자 암호를 key로 변경한다.
# 암호화 시의 해쉬와 동일한 방법을 사용해야만 한다.
key = hashlib.pbkdf2_hmac(hash_name='sha256', password=original_password, salt=b'$3kj##agh_', iterations=100000)

#복호화를 할 때에도, 다음과 같이 AES 개체를 만든다.
aes = AES.new(key, AES.MODE_ECB)

#string을 bytes로 변환
temp_str = b'\xfe\xafN\xbf\x82(\xae\xf3\x95\xfa\x8d\xd6oq\x7f\\\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02\x08\xc0\xa5\x0e\xca\xbeT\xebV\xe8Sb\n\x08\xa5\x02'

# byte_data = temp_str.decode('utf-8')
#다음과 같은 방법으로 복호화를 한다.
decrypted_text = aes.decrypt(temp_str)

#다음과 같이 블록으로 만들었던 것을 원래의 상태대로 돌린다. 이를 unpadding이라고 한다.
Block_Size = 256
unpadded_text = unpad(decrypted_text, Block_Size)
print("복호화된 비밀: ", unpadded_text.decode('utf8'))